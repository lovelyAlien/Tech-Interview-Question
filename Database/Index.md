# Index

- 순차 I/O, 랜덤 I/O
- 쿼리 튜닝의 목적
- 인덱스
- B-Tree Index, Hash Index
- MySQL 에서 B-tree 를 사용하는 이유
- 인덱스 레인지 스캔, 인덱스 풀 스캔
- 클러스터링 인덱스, 논 클러스터링 인덱스
- MySQL 에서 PK 를 인조키로 사용하고 Auto_Increment 를 사용하는 이유



## 순차  I/O, 랜덤 I/O

- 순차 I/O
  - 순차 IO는 시작 위치에서 읽기 시작하여 데이터를 찾는 것
  - 원하는 데이터 찾기 위해 full scan 방식 사용
  - 인덱스 풀 스캔에 사용

- 랜덤 IO 
  - 여러 위치 탐색하여 원하는 데이터를 찾는 것
  - 인덱스 레인지 스캔에 사용

![image](https://user-images.githubusercontent.com/93963499/163703705-e408712d-4419-4ec7-8c55-bf151530909c.png)

순차 I/O 는 3개의 페이지를 디스크에 기록하기 위해서 시스템 콜을 한 번만 요청한 반면에, 랜덤 I/O 는 세 번을 요청했다. 즉, 디스크에 기록할 위치를 찾기 위해 순차 I/O 는 `디스크 헤더`를 한 번 움직였고, 랜덤 I/O 는 헤드를 세 번 움직인 것이다.

디스크에 데이터를 쓰고 읽는 데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다. 일반적으로 순차 I/O 가 랜덤 I/O 보다 성능이 좋다.

(하지만 여기서 SSD를 사용하면 얘기가 달라진다. SSD는 HDD와 달리 플래터에 데이터를 기록하지 않고, 플래시 메모리라는 것에 데이터를 저장한다. 이는 원판을 기계적으로 회전시킬 필요가 없으므로 데이터를 매우 빠르게 찾을 수 있다. 그러므로 DBMS용 스토리지에는 SSD가 최적이라고 볼 수 있다.)

### 쿼리 튜닝의 목적

일반적으로 `쿼리를 튜닝하는 것은 랜덤 I/O 자체`를 줄여주는 것이 목적이며,  `랜덤 I/O를 줄인다는 것은 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선`하는 것을 의미한다.

## 인덱스

RDBMS에서 검색 속도를 높이기 위한 기술이다.

**테이블의 컬럼을 색인화(따로 파일로 저장)하여** 검색 시 해당 테이블의 레코드를 full scan하는게 아니라, **색인화 되어있는 index 파일을 검색하여 검색 속도를 빠르게** 한다.

RDBMS의 인덱스의 자료구조는`SortedList`와 비슷하며, 항상 컬럼을 정렬된 값으로 유지한다. `SortedList`는 정렬 상태를 유지하므로 값을 검색할 때 빠르게 가져울 수 있으나, 데이터가 새로 저장될 때마다 항상 값ㅇ르 정렬하므로 저장하는 과정이 느리다.

다시 말하면,

RDBMS에서 사용하는 인덱스는 **B-Tree를 사용해서 색인화**한다.

(보통 select 쿼리의 where절이나 join 예약어를 사용했을 때,) 인덱스가 사용되며 쿼리의 검색 속도 빠르게 하는 목적이 있다.

*DELETE, INSERT, UPDATE 쿼리에는 해당 사항이 없으며 INDEX 사용시 오히려 느려진다.*

#### 정리

인덱스(Index)

- 책의 찾아보기와 같다.
- Key 와 Value 형식으로 이루어져 있다.
- SortedList 로 구현되어있기 때문에 인덱스를 생성할 때 마다, 내부적으로 정렬 되어 저장되어있다.
- INSERT, UPDATE, DELETE 에 대한 성능을 희생하고, READ 에 대한 성능을 높이는 기능이다.

#### Index를 남발하지 말아야 하는 이유

데이터베이스 서버에 성능 문제가 발생하면, **가장 빨리 생각하는 해결책이 인덱스 추가 생성**이다.

문제가 발생할 때마다 인덱스를 생성하면서, **인덱스가 쌓여가는 것**은 하나의 쿼리를 빠르게 만들 수 있지만, 전체적인 데이터베이스 성능 부하를 초래한다.

조회 성능을 극대화하려 만든 객체인데 많은 인덱스가 쌓여서, Insert, Delete, Update 시에 부하가 발생해 전체적인 데이터베이스 성능을 저하한다.

그렇기에 인덱스를 생성하는 것보다는 sql문을 좀 더 효율적으로 짜는 방향으로 나가야 한다.

**인덱스 생성은 마지막 수단**으로 강구할 문제다.

## 인덱스 저장 방식 : B-Tree Index, Hash Index

B-Tree 방식(가장 일반적으로 많이 쓰임), 해시 방식, Fractal 방식 등이 있다.

### B-Tree

인덱스에 일반적으로 많이 사용하는 알고리즘이다.

B-Tree Index 는 컬럼의 값을 변경하지 않고, 원래의 값을 이용해 인덱싱하는 알고리즘이다.

> B-Tree 의 B 는 Binary 가 아닌 Balanced 를 의미

#### 밸런스 트리

- 일반 트리

![image](https://user-images.githubusercontent.com/93963499/163704589-1f90539d-dd6d-42ee-a790-49cb6ccbf1fd.png)

![image](https://user-images.githubusercontent.com/93963499/163704591-977b179c-de34-4a78-a882-c728fc054420.png)



일반 트리의 탐색 시간 복잡도는 O(logN)이며, 편향된 트리의 경우 O(N)이다. 이런 경우를 방지하기 위해 밸런스 트리를 적용한다. 

- 밸런스 트리란?

트리의 노드가 한 방향으로 쏠리지 않도록, 노드 삽입 및 삭제 시 특정 규칙에 맞게 재 정렬되는 트리다.
항상 양쪽 자식의 밸런스를 유지하므로 무조건 O(logN)의 시간 복잡도를 지닌다.

다만 재정렬되는 작업으로 인해 노드 삽입 및 삭제 시 일반적인 트리보다 성능이 떨어지게 된다. 그러므로 밸런스 트리는 삽입/삭제의 성능을 희생하고 탐색에 대한 성능을 높였다고 볼 수 있다. 

다시말하면,  밸런스 트리는 최악의 경우에도 O(logN)이므로, 탐색시간에 매우 효율적인 자료구조며, 인덱스는 그 중 B-Tree를 선택했다. (밸런스 트리는 RedBlack-Tree, B-Tree 등이 있다.)

#### B-Tree 특징

![image](https://user-images.githubusercontent.com/93963499/163704716-334ba28c-0d18-4711-825e-b8675c3dd917.png)

노드 하나에 여러 데이터가 저장될 수 있다. 각 노드 내 데이터들은 항상 정렬된 상태이며, 데이터와 데이터 사이의 범위를 이용하여 자식 노드를 가진다. 그러므로 자식 노드 개수는 (n+1)을 가진다. 

항상 좌, 우 자식노드 개수의 밸런스를 유지하므로 최악의 경우에도 무조건 탐색 시간이 O(logN)을 가지게 된다.

### Hash

컬럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원

하지만 값을 변형해서 인덱싱하므로, 특정 문자로 시작하는 값을 검색하는 등 전방 일치와 같이 **값의 일부만으로 검색하고자 할 때는 해시 인덱스를 사용할 수 없다.**

데이터 접근에 시간 복잡도가 O(1)인 해시테이블말고 B-Tree를 사용하는 이유는 select 절의 조건에 부등호연산이 포함되면 문제 발생한다. 해시테이블은 = 연산에 특화되어 있다. 그 이유는 해시 테이블은 데이터가 정렬되어 있지 않기 때문이다.

### MySQL 에서 B-tree 를 사용하는 이유

자세하게 설명되어 있어서 읽어보는 것을 추천합니다!! 

https://helloinyong.tistory.com/296

https://steady-coding.tistory.com/558

트리 종류에는 이진 트리(Binary-Tree), 레드 블랙 트리, B-tree 등 다양한 종류들이 존재하는데 MySQL 에서 B-tree 를 사용한다.

- 왜 보편적으로 레드 블랙 트리 대신 B-Tree 자료구조를 적용하는가?

레드 블랙 트리는 노드 하나에 데이터 하나만 저장하므로 어떠한 요소를 탐색하든 참조 포인터 접근이 필수적이다. 반면, B-Tree는 하나의 노드에 여러 개의 데이터를 저장하므로 각 노드의 데이터 요소를 탐색할 때 참조 포인터 접근 없이 배열의 성질을 이용하여 빠르게 탐색이 가능하다. 결론적으로 참조 포인터의 접근 수가 B-Tree가 훨씬 적으므로 B-Tree를 인덱스의 자료 구조로 사용한다.

- 왜 보편적으로 해시 테이블 대신 B-Tree 자료구조를 인덱스로 사용하는가?

해시 테이블 내의 데이터는 정렬이 되어 있지 않으므로 부등호 연산이 불가능하다. 인덱스의 특성상 기준 값보다 크거나 작은 요소를 탐색하는 경우가 많은데, 이러한 이유로 B-Tree를 인덱스의 자료 구조로 사용한다.

## 인덱스 레인지 스캔, 인덱스 풀 스캔

인덱스를 이용해 데이터를 읽는 법은 레인지 스캔과 풀 스캔이 있다.

### 인덱스 레인지 스캔

가장 빠른 스캔 방법이다.

**인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다.**

주로, `<`, `>`, `IS NULL`, `BETWEEN`, `IN`, `LIKE` 등의 연산을 이용하여 인덱스를 검색할 때 사용된다.

### 인덱스 풀 스캔

인덱스의 처음부터 끝까지 스캔하는 방식을 말한다.

인덱스에 저장된 데이터만으로 모든 것을 처리할 수 있는 경우이거나, 멀티인덱스의 중간 값 부터 조건을 지정하였을 경우 발생한다.

리프 노드의 첫번째 데이터 부터 순차적으로 읽어 내려가며, 하나의 리프노드가 끝났을 경우 해당 리프노드의 링크드리스트를 통해 다음 리프노드로 넘어가 끝까지 읽는 방식이다.

## 클러스터링 인덱스

클러스터링 인덱스는 기본키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 말한다. 기본키값에 의해 레코드 저장 위치가 결정되기 때문에, 기본키 값이 변경된다면 레코드의 물리적인 저장 위치가 변경되어야 한다.

InnoDB와 같이 항상 클러스터링 인덱스로 저장되는 테이블은 기본키 기반의 검색이 매우 빠른 대신, 레코드의 저장이나 기본키의 변경이 비교적 느리다. 만약 기본키가 없다면, InnoDB 스토리지 엔진은 다음 우선순위대로 컬럼을 선택한다.

 *1. NOT NULL 속성을 가지고 있는 유니크 인덱스 중에서 첫번째 인덱스를 클러스터 키로 선택*

 *2. 자동으로 유니크한 값을 가지고 증가하는 컬럼을 내부적으로 추가한 후, 클러스터 키로 선택*

2번과 같이 적절한 클러스터 키 후보를 찾지 못해서 내부적으로 자동 증가 컬럼을 추가한 경우, 사용자에게 노출되지 않고 쿼리에서 명시적으로 사용할 수 없다. 

### 장단점

기본키, 즉 클러스터 키로 검색할 때 처리가 매우 빠르며 테이블의 모든 보조 인덱스가 클러스터 키를 가지고 있기 때문에 인덱스만으로 처리할 수 있는 경우가 많다. 하지만, 모든 보조 인덱스가 클러스터 키를 가지고 있기 때문에 키값의 크기가 클 경우 전체적인 인덱스 크기가 커진다.

## MySQL 에서 PK 를 인조키로 사용하고 Auto_Increment 를 사용하는 이유

예를들어, PK 가 주민등록번호로 잡혀있다고 해보자.

PK 가 주민등록 번호로 잡게되면 `DB 성능 이슈`가 생길 수 있다. 왜 일까?

바로 클러스터링 인덱스의 특징을 떠올리면 되는데, 클러스터링 인덱스는 PK 의 등록, 변경에 있어 느리다고 하였다. 즉, AUTO_INCREMENT 로 되어있지 않으면 회원의 주민등록번호에 따라서 PK 위치 조정이 빈번하게 일어날 것이기 때문에 성능 이슈가 발생할 수 있다.

따라서, 주민등록번호를 유니크 키로 잡고, PK 를 인조키로 생성하는 것이 좋다.

### Reference

- https://github.com/NKLCWDT/cs/blob/main/Database/Index%2C%20Hint.md

- https://joont92.github.io/db/mysql-index/

- https://gyoogle.dev/blog/computer-science/data-base/Index-.html
- https://helloinyong.tistory.com/296
- https://steady-coding.tistory.com/558
- https://lkhlkh23.tistory.com/112

- https://bangsj1224.tistory.com/entry/%EA%B8%B0%EB%B3%B8%ED%82%A4%EC%99%80-AutoIncrement