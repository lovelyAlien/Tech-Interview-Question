- 레디스
	- 레디스란?
		- Remote Dictionary Server의 약자이며, Key-Value 구조의 비정형 데이터를 저장하고 관리하기 위한 NoSQL이며<br>
		  DB뿐만 아니라, Cache, Message Broker, Streaming Engine으로도 사용된다.

		- MessageBroker
			- 실시간 데이터를 처리할 때, A라는 서버는 데이터 수집 서버, B라는 서버는 수집된 데이터를 가공해서 사용하는 서버 라고 가정해보자<br>
			  B서버가 A 서버의 데이터를 실시간으로 조회하여 데이터를 처리할 수는 있지만, 성능이 그렇게 좋지는 않다.<br>
			  그래서 MessageBroker를 이용하여 처리하면 속도를 더 빠르게 할 수 있는데 이러한 방식을 Publisher/Subscriber 라고 부른다.<br><br>
			  Publisher는 데이터를 전송하는 쪽이고, Subscriber는 데이터를 받아서 처리하는 쪽이다.<br>
			  이 중간 지점의 MessageBroker는 Message Queue 안에 Publisher로부터 온 데이터를 보관하고,<br>
			  Subscriber는 굳이 조회 쿼리를 던지지 않고 데이터를 가져올 수 있다.<br><br>
			  이러한 점 덕분에 조회 쿼리를 사용하는 것보다 성능이 더 빠르지만, 단점은 쿼리를 사용해서 가져오는 것이 아니기 때문에<br>
			  순수 적재된 데이터를 가져와서 가공시켜서 사용하거나, 적재할 때 필터링된 데이터를 적재하거나 혹은 Logstach로 필터링해서 사용해야 한다.<br><br>

			  *Logstach = 데이터 처리 파이프라인에 사용되는 경량 오픈 소스<br>
			  *Apache Kafka, RabbitMQ 등이 대표적인 MessageBroker 오픈 소스다.


	- 특징
		- 인메모리 데이터 구조
			- 모든 데이터를 디스크가 아닌, 메모리에 저장하고 조회한다. 따라서, I/O 속도가 빠르다.<br>
	
		- 다양한 데이터 형식 지원
			- value값으로 String, List, Set, Hash 등 여러 데이터 형식을 지원한다.
		
		- 트랜잭션
			- 레디스의 트랜잭션은 직렬화(Object -> Byte)가 되고, 순서를 보장하면서 실행한다.<br>
			  따라서, 중간에 다른 트랜잭션이 추가되어도, 실행 순서는 보장된다.

			- 레디스는 트랜잭션의 롤백 기능을 제공하지 않는다.<br>
			  그 이유는 레디스가 추구하는 간편성과 성능에 영향을 미치기 때문이다.
			  
		- 센티넬
			- 기능
				- 모니터링 = 마스터/슬레이브가 문제없이 작동중인지 지속적으로 확인.
				- 공지 = 레디스 인스턴스에 문제가 생기면 시스템 관리자에게 공지.
				- 자동장애복구 = 마스터가 죽으면, 자동으로 슬레이브를 마스터로 승격시키고,<br>
				  죽었던 마스터가 살아나면, 이전에 승격된 마스터의 슬레이브가 된다.

		- 클러스터
			- 기능
				- 샤딩 = 자동으로 데이터를 분산시켜서 저장한다.
				- 자동장애복구 = 센티넬과 동일하다.
		
		- 센티넬과 클러스터의 차이점
			- 센티넬은 하나의 마스터 구조를 가지기 때문에 데이터 사이즈가 커지면,<br>
			  ScaleUp(하드웨어 성능 업그레이드)을 해야 하지만, 클러스터는 ScaleOut(서버 추가)이 가능하다.
			  
	
	- 레디스의 메모리
		- 물리적인 메모리보다 더 초과해서 사용할 수 없기 때문에 메모리 관리가 매우 중요하다.
		- 메모리가 부족할 경우, SWAP을 활용하는데 SWAP이란 간단히 말해서, 메모리 용량이 부족하여<br>
		  하드디스크에 SWAP 공간을 만들어서 임시적으로 사용하는 것이다.<br>
		  문제는 이러한 SWAP이 일어날 때, 레이턴시가 발생하므로, 속도가 느려진다.<br>
		  즉, Redis의 속도가 느려진다는 것은 메모리 관리가 제대로 되지 않고 있다는 뜻이다.
	
	- 레디스의 장점
		- 리스트 형식의 경우, 입력 및 삭제 속도가 Mysql에 비해 약 10배 빠르다.
		- 여러 프로세스에서 동시에 같은 Key에 대한 갱신을 요청할 경우, 안정성을 보장한다.<br>
		  즉, 데이터 정합성을 유지시켜주는 함수를 제공해준다.
		- 다중 서버 구성을 할 수 있으며, 기존 RDBMS처럼 Master와 Slave 형식으로 구성도 가능하다.
	
	- 레디스의 용도
		- 메인 DB로 사용하기 보다는 보조 DB로 사용한다.
		- 그래서 일종의 캐시DB 역할을 한다고 보면 된다.

	- CAP
		- Consistency 일관성 = 데이터의 일관성이 깨지면 안 된다. 즉, 항상 동일한 데이터를 유지해야 한다.
		- Availiability 가용성 = 읽기/쓰기가 가능해야 한다.
		- Partition Tolerance 지속성 = 데이터 손실이 발생하더라도, 서비스는 지속되어야 한다.

		- 레디스는 C와 P의 조합이라고 하는데, 단일 노드의 경우 일관성이 지켜져서 맞는 조합이 되지만,<br>
		  분산 시스템으로 구축하면, 마스터/슬레이브로 구성되기 때문에 일관성을 완벽히 지킬수는 없다.<br>
		  그리고 CA는 RDBMS의 조합이다. 일관성과 가용성을 제공하지만, 데이터 손실이 발생할 경우, 네트워크가 다운될 수 있다.




- 참고
- https://stackoverflow.com/questions/59511275/redis-availability-and-cap-theorem
- https://redis.io/docs/manual/sentinel/
- https://redis.io/docs/reference/cluster-spec/
- https://velog.io/@always/Redis-%EC%9A%B4%EC%98%81-%EB%B0%A9%EC%8B%9D-Cluster-vs-Sentinel-%EC%96%B4%EB%96%A4-%EA%B2%83%EC%9D%84-%EC%84%A0%ED%83%9D%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C
- https://zangzangs.tistory.com/72
