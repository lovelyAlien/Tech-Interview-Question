# 페이징과 세그멘테이션

- 메모리 관리 비법

- 페이징
- 페이징 스와핑
- 세그멘테이션

- 비교



## 메모리 관리 기법

물리 메모리 공간이 제한되어 있으므로, 효율적으로 메모리 할당하자!

#### 연속 메모리 관리 기법

프로그램 전체가 메모리에 연속적으로 할당되어야 하는 기법

- 고정 분할 기법 -> 내부 단편화 발생 
- 가변 분할 기법 : 메모리 할당 알고리즘 (first-fit, best-fit, worst-fit) -> 외부 단편화 발생

> 내부 단편화 : 프로세스가 필요한 양보다 더 큰 메모리가 할당되어, 프로세스에서 사용하는 메모리 공간이 낭비되는 현상
>
> 외부 단편화 : 할당된 메모리 사이에 작은 메모리가 생겨, 총 메모리 공간은 충분하지만 실제로는 할당할 수 없는 상황

#### 비연속 메모리 관리 기법

프로그램 일부가 서로 다른 주소 공간에 할당될 수 있는 기법

- 페이징 

- 세그멘테이션



## 페이징

![image](https://user-images.githubusercontent.com/38436013/128986032-f52b7814-1c6b-42bc-b7e1-dc10cc9ffbec.png)

- 프로세스와 메모리 HOLE을 작은 단위로 나누어 외부 단편화를 해결하는 기법
- 프로세스는 **물리적 단위인 페이지**로 나뉘고, 물리 메모리는 **프레임**으로 나뉘어 **비연속적으로 할당**하는 메모리 기법 (잘린 프로세스 조각 = 페이지, 잘린 물리 메모리 조각 = 프레임)
  - 메모리 = 프레임 SET
  - 프로세스 = 페이지 SET
- 페이지 테이블에는 (각 페이지 번호, 해당 페이지가 할당된 프레임의 시작 물리 주소)를 저장
- CPU는 논리 주소로 연속적인 주소값을 주고, 이는 메모리로 가기전에 테이블에서 물리 주소로 변경

#### 장점

- 메모리 공간을 연속적으로 사용해야한다는 제약을 없앰 -> 외부 단편화 없다!!

#### 단점

- 페이지 크기보다 작은 메모리 요청하는 경우 발생 -> 내부 단편화 발생

예를들어 페이지 크기가 4KB인데 10KB의 메모리를 필요하는 프로세스는 이 페이지가 2개 + 2KB할당되는 것이 아니라 3개가 할당되어야지만 10KB메모리를 쓸 수 있다. 마지막으로 할당된 페이지는 실제로 프로세스가 2KB 만 사용하고 나머지 2KB는 사용하지 않은 메모리가 된다. -> 2KB 내부 단편화 발생

#### 정리

- 페이징에서 페이지 단위는 고정적
- 페이지 크기가 작을수록, 
  - 장점 : 내부 단편화는 줄어든다.
  - 단점 : 페이지 부재 증가(CPU에서 요청한 페이지가 메모리에 없는 경우)  



## 페이징 스와핑

페이징 스와핑 : 페이지 단위로 스와핑하는 방식(프로세스 스와핑 : 프로세스 단위로 스와핑)
![image](https://user-images.githubusercontent.com/93963499/161415577-52ef6e68-5edd-4ef7-8757-1a26f0723ad4.png)

#### 페이지 테이블과 TLB

CPU안에  MMU와 TLB가 있다. 

페이지 테이블의 경우, 주로 메모리 쪽에 있다.

MMU는 TLB(Translation Lookaside Buffer) 이라는 소형 캐시를 저장하고 있다.

- 가상 주소가 물리 주소로 변환되어야 할 때, `TLB에서 우선 검색`
  - 해당되는 물리 주소 있다면, 물리 주소 리턴하고 메모리에 접근
- TLB에서 해당되는 물리 주소가 없다면, `페이지 테이블에서 맵핑이 존재하는지 탐색`
- 존재한다면, 가상 주소를 이용해 물리 주소 변환하고, 메모리에 접근
- 페이지 테이블에서 못찾는 경우, `디스크에서 찾아서` 그 값을 다시 페이지 테이블에서 쓰고, TLB에서 쓰고 물리주소로 변환 후 메모리에 접근
- TLB 내의 각 항목은 `KEY 와 VALUE` 로 구성된다. TLB 에 페이지를 찾아달라고 요청이 들어오면 이 찾고자 하는 페이지를 동시에 여러 개의 내부 키(페이지 번호)와 비교하고, 페이지 번호가 같은 것이 발견되면 프레임 번호를 알려준다.
- 정리하면, , 가상 주소를 갖고 물리 주소에 접근할 때 *TLB -> page table -> disk 순으로 접근*

![image](https://user-images.githubusercontent.com/93963499/161415890-3357715c-efab-4a27-a86d-286720781a7e.png)



## 세그멘테이션

![image](https://user-images.githubusercontent.com/38436013/128990113-f69a1e81-6d33-4b01-a907-99326fdc6871.png)

- 메모리를 **서로 크기가 다른 논리적인 단위인 세그멘트로 분할하여 메모리를 할당**하는 기법
- 프로그래머가 인지하는 메모리의 모습을 물리 메모리의 모습으로 변환해주는 메모리 기법
- 논리적인 단위?
  - 세그멘테이션은 프로세스를 세그먼트의 집합으로 만든다.
  - 프로세스는 코드, 데이터, 스택 등이 있는데, 세그먼트도 코드, 데이터, 스택으로 나눌 수 있음 (그 중 코드내부에는 함수, 배열 등 있는데, 이것도 작은 세그먼트로 나눌 수 있음)
  - 물리적 크기 단위가 아니라 논리적 내용의 단위로 자르기 때문에 세그먼트는 크기가 동일하지 않음

- 세그먼트 테이블은 페이징 테이블과 다르게 (세그먼트 번호, 세그먼트 시작 주소(BASE), 세그먼트 길이(LIMIT))을 저장한다.

- 물리 주소는 세그먼트 테이블에 있는 BASE와 LIMIT을 이용해 구하며, 이 값이 각 세그먼트 크기를 넘어서면, 프로세스를 강제 종료시킨다
  - 논리 주소 표현  (세그먼트 번호, 변위)
  - 논리주소 (2, 100) => 물리주소 4400번지, 프로세스 메모리에 할당됨
  - 논리주소 (1, 500) => 인터럽트로 인해 프로세스 강제 종료(범위를 벗어남)

#### 장점

- 보호와 공유 면에서 효과적
  - 세그멘테이션이 논리적 단위이므로, 코드 영역은 코드 영역으로 잘리게 되는 방식이다.
  - 이때, 중요한 세그먼트와 중요하지 않은 세그먼트를 논리적 단위로 자를 수 있기 때문에 보호와 공유가 가능해진다. (페이징의 경우, 페이지 단위로 잘리므로, 코드 영역 또한 중요한 부분과 중요하지 않은 부분을 구분하지 못하고 잘릴 수 있다.)
  - 특히, 두 프로세스가 같은 코드를 공유할 때 용이
    - 프로세스들이 공유하는 코드 영역은 메모리에서 그대로 두고, 나머지 세그먼트 영역들에 대해서만 교체를 하므로 컨텍스트 스위칭 발생이 적어진다.

#### 단점

- 서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다 보면, 자유 공간들이 많은 수의 작은 조각들로 나누어져 못 쓰게 될 수도 있다.(외부 단편화)



## 페이징 VS 세그멘테이션

#### 공통점

- 메모리 단편화 문제 해결 기법
- 멀티프로그래밍에서 여러 프로세스 수용하기 위해 메모리를 동적 분할하는 메모리 관리 기법이 필요했음

#### 차이점

- 페이징은 고정 단위
- 세그멘테이션은 가변(동적) 단위
- 페이징은 내부 단편화 발생 가능, 세그멘테이션은 외부 단편화 발생 가능



## QnA

- 메모리 기법 구분
- 페이징 개념, 장 단
- 세그멘테이션 개념, 장 단
- 페이징과 세그멘테이션의 차이점



### Reference

- https://github.com/NKLCWDT/cs/blob/main/Operating%20System/%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98%EA%B3%BC%20%ED%8E%98%EC%9D%B4%EC%A7%95.md
- https://about-myeong.tistory.com/35

- https://copycode.tistory.com/108

- https://velog.io/@nnnyeong/OS-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94-%ED%8E%98%EC%9D%B4%EC%A7%95-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98

- https://jeongmorecord.tistory.com/97
- https://goodmilktea.tistory.com/31

- https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-12.-%EC%A3%BC%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98%EA%B4%80%EB%A6%AC

- http://itnovice1.blogspot.com/2019/08/blog-post_78.html